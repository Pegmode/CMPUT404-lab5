<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dchu lab5</title><link href="https://pegmode.github.io/CMPUT404-lab5/" rel="alternate"></link><link href="https://pegmode.github.io/CMPUT404-lab5/feeds/all.atom.xml" rel="self"></link><id>https://pegmode.github.io/CMPUT404-lab5/</id><updated>2022-02-11T08:00:00-07:00</updated><entry><title>Other article</title><link href="https://pegmode.github.io/CMPUT404-lab5/other-article.html" rel="alternate"></link><published>2022-02-11T08:00:00-07:00</published><updated>2022-02-11T08:00:00-07:00</updated><author><name>Pegmode</name></author><id>tag:pegmode.github.io,2022-02-11:/CMPUT404-lab5/other-article.html</id><summary type="html">&lt;p&gt;I don't really want to write anything else for these lab examples so I'm just going to write a ramble here unlike the game boy article example.&lt;/p&gt;
&lt;p&gt;I think this class is pretty neat but sometimes I'm really lost with what we're doing. I think programming in general can be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I don't really want to write anything else for these lab examples so I'm just going to write a ramble here unlike the game boy article example.&lt;/p&gt;
&lt;p&gt;I think this class is pretty neat but sometimes I'm really lost with what we're doing. I think programming in general can be like that. You can get good at a specific topic but there will always be some kind of system/library built on a bunch of abstractions you don't fully understand. I just think that's the nature of being a programmer. &lt;/p&gt;</content><category term="Blog"></category></entry><entry><title>Game Boy Dev</title><link href="https://pegmode.github.io/CMPUT404-lab5/game-boy-dev.html" rel="alternate"></link><published>2022-02-10T08:00:00-07:00</published><updated>2022-02-10T08:00:00-07:00</updated><author><name>Pegmode</name></author><id>tag:pegmode.github.io,2022-02-10:/CMPUT404-lab5/game-boy-dev.html</id><summary type="html">&lt;p&gt;Modern Game boy dev is pretty cool. Your choices for development boil down to: 
- the C compiler &lt;a href="https://github.com/gbdev/rgbds"&gt;Game Boy SDK (GBSDK)&lt;/a&gt;
- the assembler &lt;a href="https://github.com/gbdev/rgbds"&gt;Rednex Game Boy Development System (RGBDS)&lt;/a&gt;
- &lt;a href="https://github.com/gbdev/rgbds"&gt;GB Studio&lt;/a&gt;, a drag and drop game creator working on top of GBSDK&lt;/p&gt;
&lt;p&gt;Many people choose GBSDK since they feel that …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Modern Game boy dev is pretty cool. Your choices for development boil down to: 
- the C compiler &lt;a href="https://github.com/gbdev/rgbds"&gt;Game Boy SDK (GBSDK)&lt;/a&gt;
- the assembler &lt;a href="https://github.com/gbdev/rgbds"&gt;Rednex Game Boy Development System (RGBDS)&lt;/a&gt;
- &lt;a href="https://github.com/gbdev/rgbds"&gt;GB Studio&lt;/a&gt;, a drag and drop game creator working on top of GBSDK&lt;/p&gt;
&lt;p&gt;Many people choose GBSDK since they feel that C programming is much easier to work with. For example, the most popular modern GB game engine &lt;a href="https://github.com/Zal0/ZGB"&gt;ZGB&lt;/a&gt; is built on top of GBSDK. &lt;/p&gt;
&lt;p&gt;For the Game Boy's CPU architecture; the common understanding is that the C compiler general writes code that is as fast as assembly for the most part does not necessarily hold. &lt;/p&gt;
&lt;p&gt;In many cases you can write a relatively small test ROM and do things like track sprites and manipulate the screen by playing music and such. If you run both programs in an emulator that can track CPU time/frame (such as &lt;a href="https://bgb.bircd.org/"&gt;BGB&lt;/a&gt;) you may notice that the C program is noticeably quite a lot slower. Why is this?&lt;/p&gt;
&lt;p&gt;Among other things, one the greatest sources of the slowdown is C's reliance on the stack for passing function arguements. While there are instructions specifically for manipulating the game boys stack (&lt;code&gt;PUSH/POP&lt;/code&gt;) they are very slow. The game boy does not have pipelining or any of the modern speedup methods that modern CPU archetectures use. This means that the &lt;code&gt;PUSH/POP&lt;/code&gt; can take many more cycles than say loading a value simply into a work register or loading from a static address. &lt;/p&gt;</content><category term="Blog"></category></entry><entry><title>My First Article</title><link href="https://pegmode.github.io/CMPUT404-lab5/my-first-article.html" rel="alternate"></link><published>2022-01-01T08:00:00-07:00</published><updated>2022-01-01T08:00:00-07:00</updated><author><name>Pegmode</name></author><id>tag:pegmode.github.io,2022-01-01:/CMPUT404-lab5/my-first-article.html</id><content type="html">&lt;p&gt;Woah this is pretty cool.&lt;/p&gt;</content><category term="Blog"></category></entry></feed>